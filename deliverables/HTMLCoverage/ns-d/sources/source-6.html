


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > CommonGoalStrategy</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">it.polimi.ingsw.shared.model</a>
</div>

<h1>Coverage Summary for Class: CommonGoalStrategy (it.polimi.ingsw.shared.model)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CommonGoalStrategy</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.8%
  </span>
  <span class="absValue">
    (23/24)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CommonGoalStrategy$Predicates</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (23/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (108/126)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CommonGoalStrategy$Predicates$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CommonGoalStrategy$Predicates$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CommonGoalStrategy$Predicates$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CommonGoalStrategy$Predicates$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CommonGoalStrategy$Predicates$5</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CommonGoalStrategy$Predicates$6</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CommonGoalStrategy$Predicates$7</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CommonGoalStrategy$Predicates$8</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    97.8%
  </span>
  <span class="absValue">
    (45/46)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.6%
  </span>
  <span class="absValue">
    (179/202)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package it.polimi.ingsw.shared.model;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.IntStream;
&nbsp;
<b class="fc">&nbsp;public enum CommonGoalStrategy {</b>
&nbsp;    //Name                    ID    Predicate
<b class="fc">&nbsp;    SixGroupsOf2(           1,   Predicates.groups(6,2),</b>
&nbsp;            &quot;Shelf should contain 6 non adjacent groups of 2 tiles&quot;),
<b class="fc">&nbsp;    TwoSquares(             2,   Predicates.nSquares(2),</b>
&nbsp;            &quot;Shelf should contain 2 non adjacent 2x2 squares&quot;),
<b class="fc">&nbsp;    EqualTilesInAllCorners( 3,   Predicates.corners(Predicates.maxNtypes(1)),</b>
&nbsp;            &quot;Tiles in all corners of the shelf should be equal&quot;),
<b class="fc">&nbsp;    ThreeColumnsWith3Types( 4,   Predicates.columns(3,Predicates.maxNtypes(3)),</b>
&nbsp;            &quot;The shelf should have 3 full columns with max 3 types of tiles each&quot;),
<b class="fc">&nbsp;    TwoAllDifferentColumns( 5,   Predicates.columns(2,Predicates.notEmptyAndAllDifferent),</b>
&nbsp;            &quot;The shelf should have 2 full columns with all different tiles&quot;),
<b class="fc">&nbsp;    EightEqualTiles(        6,   Predicates.nEqualTiles(8),</b>
&nbsp;            &quot;The shelf should have 8 equal tiles&quot;),
<b class="fc">&nbsp;    Ladders(                7,   Predicates.ladder,</b>
&nbsp;            &quot;The shelf should have a full diagonal filled with tiles&quot;),
<b class="fc">&nbsp;    FourLineWith3Types(     8,   Predicates.rows(4,Predicates.maxNtypes(3)),</b>
&nbsp;            &quot;The shelf should have 3 full lines with max 3 types of tiles each&quot;),
<b class="fc">&nbsp;    TwoAllDifferentLines(   9,   Predicates.rows(2,Predicates.notEmptyAndAllDifferent),</b>
&nbsp;            &quot;The shelf should have 2 full lines with all different tiles&quot;),
<b class="fc">&nbsp;    FullLadder(            10,   Predicates.fullLadder,</b>
&nbsp;            &quot;The shelf should have a ladder of tiles&quot;),
<b class="fc">&nbsp;    FourGroupsOf4(         11,   Predicates.groups(4,4),</b>
&nbsp;            &quot;Shelf should contain 4 non adjacent groups of 4 tiles&quot;),
<b class="fc">&nbsp;    EqualX(                12,   Predicates.equalX,</b>
&nbsp;            &quot;Shelf should contain an \&quot;X\&quot; of equal tiles&quot;),
&nbsp;    ;
&nbsp;    private final int id;
&nbsp;    private final Predicate&lt;Shelf&gt; check;
&nbsp;    private final String description;
&nbsp;
<b class="fc">&nbsp;    CommonGoalStrategy(int id, Predicate&lt;Shelf&gt; check, String description) {</b>
<b class="fc">&nbsp;        this.id = id;</b>
<b class="fc">&nbsp;        this.check = check;</b>
<b class="fc">&nbsp;        this.description = description;</b>
&nbsp;    }
&nbsp;
&nbsp;    int getId() {
<b class="fc">&nbsp;        return id;</b>
&nbsp;    }
&nbsp;
&nbsp;    Predicate&lt;Shelf&gt; getCheck() {
<b class="fc">&nbsp;        return check;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static CommonGoalStrategy findById(int id) {
<b class="fc">&nbsp;        return Arrays.stream(values()).</b>
<b class="fc">&nbsp;                filter(x -&gt; x.getId() == id).</b>
<b class="fc">&nbsp;                findFirst().</b>
<b class="fc">&nbsp;                orElseThrow();</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getDescription() {
<b class="nc">&nbsp;        return description;</b>
&nbsp;    }
&nbsp;
&nbsp;    //PREDICATES PASSED TO COMMON GOALS
&nbsp;    private static class Predicates {
&nbsp;        //PREDICATES ON COLLECTIONS OF TILES (called by most of Predicate&lt;Shelf&gt;)
&nbsp;        /**
&nbsp;         * true if the list of tiles does not contain empty Tiles and they are all different
&nbsp;         */
<b class="fc">&nbsp;        static Predicate&lt;List&lt;Tile&gt;&gt; notEmptyAndAllDifferent = new Predicate&lt;List&lt;Tile&gt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public boolean test(List&lt;Tile&gt; tiles) {
&nbsp;                try {
<b class="fc">&nbsp;                    return  tiles.size() &gt; 0 &amp;&amp; //tiles should not be empty</b>
<b class="fc">&nbsp;                            !tiles.contains(Tile.Empty) &amp;&amp; //none of the tiles is Empty</b>
<b class="fc">&nbsp;                            tiles.stream().distinct().count() == tiles.size(); //all tiles are different</b>
<b class="nc">&nbsp;                } catch (NullPointerException e) {</b>
<b class="nc">&nbsp;                    throw new CommonGoalRuntimeException(&quot;Error while checking notEmptyAndAllDifferent : tiles is null pointer&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        };
&nbsp;        /**
&nbsp;         * true if the list of tiles does not contain empty Tiles and there are at most n types
&nbsp;         * if n == 1 it means that all tiles are not empty and equal
&nbsp;         */
&nbsp;        static Predicate&lt;List&lt;Tile&gt;&gt; maxNtypes(int n){
<b class="fc">&nbsp;            return new Predicate&lt;List&lt;Tile&gt;&gt;() {</b>
&nbsp;                @Override
&nbsp;                public boolean test(List&lt;Tile&gt; tiles) {
&nbsp;                    try {
<b class="fc">&nbsp;                        return  tiles.size() &gt; 0 &amp;&amp; //tiles should not be empty</b>
<b class="fc">&nbsp;                                !tiles.contains(Tile.Empty) &amp;&amp; //none of the tiles is Empty</b>
<b class="fc">&nbsp;                                tiles.stream().distinct().count() &lt;= n; //there are at most n types</b>
&nbsp;
<b class="nc">&nbsp;                    } catch (NullPointerException e) {</b>
<b class="nc">&nbsp;                        throw new CommonGoalRuntimeException(&quot;Error while checking maxThreeTypes : tiles is null pointer&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            };
&nbsp;        }
&nbsp;
&nbsp;        //ACTUAL PREDICATES
&nbsp;        /**
&nbsp;         * is true when the shelf contains n equal tiles
&nbsp;         */
&nbsp;        static Predicate&lt;Shelf&gt; nEqualTiles(int n){
<b class="fc">&nbsp;            return new Predicate&lt;Shelf&gt;() {</b>
&nbsp;                @Override
&nbsp;                public boolean test(Shelf shelf) {
&nbsp;                    Tile currentTile;
&nbsp;                    //initialize counters for all tyle of Tiles
<b class="fc">&nbsp;                    HashMap&lt;Tile, Integer&gt; counters = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;                    for (Tile tile : Tile.values()) {</b>
<b class="fc">&nbsp;                        counters.put(tile, 0);</b>
&nbsp;                    }
&nbsp;                    //count all tiles in different counters
<b class="fc">&nbsp;                    countAllTiles(shelf,counters);</b>
&nbsp;                    //true if at least one counter is &gt;= n
<b class="fc">&nbsp;                    return counters.values().stream().filter(x -&gt; x &gt;= n).count() &gt; 0;</b>
&nbsp;                }
&nbsp;            };
&nbsp;        }
&nbsp;
&nbsp;        static void countAllTiles(Shelf shelf, HashMap&lt;Tile, Integer&gt; counters){
&nbsp;            Tile currentTile;
<b class="fc">&nbsp;            for (int row = 0; row &lt; shelf.getRows(); row++) {</b>
<b class="fc">&nbsp;                for (int column = 0; column &lt; shelf.getColumns(); column++) {</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        currentTile = shelf.getTile(row, column);</b>
<b class="nc">&nbsp;                    } catch (BadPositionException e) {</b>
<b class="nc">&nbsp;                        throw new CommonGoalRuntimeException(&quot;Error in test&quot;); //TODO handle better</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    if (shelf.isValidTile(row, column)) {</b>
&nbsp;                        //increment counter
<b class="fc">&nbsp;                        counters.put(currentTile, counters.get(currentTile) + 1);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * is true when n lines test true on the predicate
&nbsp;         */
&nbsp;        static Predicate&lt;Shelf&gt; rows(int number, Predicate&lt;List&lt;Tile&gt;&gt; toCheck){
<b class="fc">&nbsp;            return new Predicate&lt;Shelf&gt;(){</b>
&nbsp;                @Override
&nbsp;                public boolean test(Shelf shelf){
&nbsp;                    //for all rows test predicate
<b class="fc">&nbsp;                    Long result = IntStream.range(0, shelf.getRows())</b>
<b class="fc">&nbsp;                            .filter(row -&gt; toCheck.test(shelf.allTilesInRow(row)))</b>
<b class="fc">&nbsp;                            .count();</b>
<b class="fc">&nbsp;                    return Math.toIntExact(result) &gt;= number;</b>
&nbsp;                }
&nbsp;            };
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * is true when n columns test true on the predicate
&nbsp;         */
&nbsp;        static Predicate&lt;Shelf&gt; columns(int number, Predicate&lt;List&lt;Tile&gt;&gt; toCheck){
<b class="fc">&nbsp;            return new Predicate&lt;Shelf&gt;(){</b>
&nbsp;                @Override
&nbsp;                public boolean test(Shelf shelf){
&nbsp;                    //for all columns test predicate
<b class="fc">&nbsp;                    Long result = IntStream.range(0, shelf.getColumns())</b>
<b class="fc">&nbsp;                            .filter(column -&gt; toCheck.test(shelf.allTilesInColumn(column)))</b>
<b class="fc">&nbsp;                            .count();</b>
<b class="fc">&nbsp;                    return Math.toIntExact(result) &gt;= number;</b>
&nbsp;                }
&nbsp;            };
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * is true when all corners of the shelf are not Empty and Equal
&nbsp;         */
&nbsp;        static Predicate&lt;Shelf&gt; corners(Predicate&lt;List&lt;Tile&gt;&gt; toCheck){
<b class="fc">&nbsp;            return new Predicate&lt;Shelf&gt;() {</b>
&nbsp;                @Override
&nbsp;                public boolean test(Shelf shelf) {
<b class="fc">&nbsp;                    return toCheck.test(shelf.getCorners());</b>
&nbsp;                }
&nbsp;            };
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * is true when the shelf contains an &quot;x&quot; shape of non-empty and equals tiles
&nbsp;         */
<b class="fc">&nbsp;        static Predicate&lt;Shelf&gt; equalX = (shelf) -&gt; {</b>
<b class="fc">&nbsp;            int columns = shelf.getColumns();</b>
<b class="fc">&nbsp;            int rows = shelf.getRows();</b>
&nbsp;            //Shelf too small to complete goal
<b class="fc">&nbsp;            if (columns &lt; 3 || rows &lt; 3) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;            //Look for an &quot;x&quot; shape of tiles that are equal and not Empty
<b class="fc">&nbsp;            for (int row = 0; row &lt; rows - 2; row++) {</b>
<b class="fc">&nbsp;                for (int column = 0; column &lt; columns - 2; column++) {</b>
<b class="fc">&nbsp;                    if (Predicates.maxNtypes(1).test(getXShape(shelf, row, column))) {</b>
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return false;</b>
&nbsp;        };
&nbsp;        static private ArrayList&lt;Tile&gt; getXShape(Shelf shelf, int row, int column) {
&nbsp;            try {
&nbsp;                //coolect tiles in an X shape
<b class="fc">&nbsp;                ArrayList&lt;Tile&gt; tiles = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;                tiles.add(shelf.getTile(row, column));</b>
<b class="fc">&nbsp;                tiles.add(shelf.getTile(row + 1, column + 1));</b>
<b class="fc">&nbsp;                tiles.add(shelf.getTile(row + 2, column + 2));</b>
<b class="fc">&nbsp;                tiles.add(shelf.getTile(row, column + 2));</b>
<b class="fc">&nbsp;                tiles.add(shelf.getTile(row + 2, column));</b>
<b class="fc">&nbsp;                return tiles;</b>
<b class="nc">&nbsp;            } catch (BadPositionException e) {</b>
<b class="nc">&nbsp;                throw new CommonGoalRuntimeException(&quot;Error in getXshape&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * is true when the shelf contains n perfect squares
&nbsp;         */
&nbsp;        static Predicate&lt;Shelf&gt; nSquares(int n){
<b class="fc">&nbsp;            return new Predicate&lt;Shelf&gt;(){</b>
&nbsp;                @Override
&nbsp;                public boolean test(Shelf shelf){
<b class="fc">&nbsp;                    int columns = shelf.getColumns();</b>
<b class="fc">&nbsp;                    int rows = shelf.getRows();</b>
<b class="fc">&nbsp;                    int equalSquaresCounter = 0;</b>
<b class="fc">&nbsp;                    boolean[][] visited = new boolean[rows][columns];</b>
&nbsp;                    Position currentPos;
&nbsp;                    //count all perfect squares (no overlap or adjacency nor Shapes that contains squares)
<b class="fc">&nbsp;                    for (int row = 0; row &lt; rows - 1; row++) {</b>
<b class="fc">&nbsp;                        for (int column = 0; column &lt; columns - 1; column++) {</b>
<b class="fc">&nbsp;                            currentPos = new Position(row,column);</b>
&nbsp;                            //if perfect square is found increase the counter
<b class="fc">&nbsp;                            if (isPerfectSquare(shelf, visited, currentPos)) {</b>
<b class="fc">&nbsp;                                markSquareAsUsed(visited, currentPos);</b>
<b class="fc">&nbsp;                                equalSquaresCounter++;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                    //true if there are more than n squares
<b class="fc">&nbsp;                    return equalSquaresCounter &gt;= n;</b>
&nbsp;                }
&nbsp;            };
&nbsp;        }
&nbsp;
&nbsp;        static private void markSquareAsUsed(boolean[][] visited, Position position) {
<b class="fc">&nbsp;            for(Position pos: position.square()){</b>
<b class="fc">&nbsp;                visited[pos.getRow()][pos.getColumn()] = true;</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        static private boolean isPerfectSquare(Shelf shelf, boolean[][] visited, Position position) {
<b class="fc">&nbsp;            List&lt;Position&gt; square = position.square();</b>
<b class="fc">&nbsp;            return  //none is already used</b>
<b class="fc">&nbsp;                    square.stream().allMatch(pos-&gt; !visited[pos.getRow()][pos.getColumn()]) &amp;&amp;</b>
&nbsp;                    //there are exactly 4 squares in the island
<b class="fc">&nbsp;                    4 == validIslandSize(shelf, position, visited) &amp;&amp;</b>
&nbsp;                    //test if all tiles are equal
<b class="fc">&nbsp;                    maxNtypes(1).test(position.square().stream().map(p -&gt; {</b>
&nbsp;                        //forall the positions in the square
&nbsp;                        try {
<b class="fc">&nbsp;                            return shelf.getTile(p); //get tile</b>
<b class="nc">&nbsp;                        } catch (BadPositionException e) {</b>
<b class="nc">&nbsp;                            return Tile.Empty; //get empty if out of bounds ==&gt; test will fail</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }).collect(Collectors.toList()));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * is true when the shelf contains n groups of the required size
&nbsp;         */
&nbsp;        static Predicate&lt;Shelf&gt; groups(int number_of_groups, int size_of_groups){
<b class="fc">&nbsp;            return new Predicate&lt;Shelf&gt;() {</b>
&nbsp;                @Override
&nbsp;                public boolean test(Shelf shelf) {
<b class="fc">&nbsp;                    int rows = shelf.getRows();</b>
<b class="fc">&nbsp;                    int columns = shelf.getColumns();</b>
<b class="fc">&nbsp;                    boolean[][] alreadyChecked = new boolean[rows][columns];</b>
<b class="fc">&nbsp;                    int groups_found = 0;</b>
<b class="fc">&nbsp;                    for (int row = 0; row &lt; rows; row++) {</b>
<b class="fc">&nbsp;                        for (int column = 0; column &lt; columns; column++) {</b>
&nbsp;                            //the size of the island are bigger than the requested size
<b class="fc">&nbsp;                            if (validIslandSize(shelf, new Position(row, column), alreadyChecked) &gt;= size_of_groups) {</b>
<b class="fc">&nbsp;                                groups_found++;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                    //true if more than n groups are found
<b class="fc">&nbsp;                    return groups_found &gt;= number_of_groups;</b>
&nbsp;                }
&nbsp;            };
&nbsp;        }
&nbsp;        static private int recursiveIslandVisit(Shelf shelf, Position position, boolean[][] visited, Tile type) {
<b class="fc">&nbsp;            int row = position.getRow();</b>
<b class="fc">&nbsp;            int column = position.getColumn();</b>
<b class="fc">&nbsp;            int result = 0;</b>
&nbsp;            //add no tiles if the position is out of bounds or already visited
<b class="fc">&nbsp;            if (shelf.isOutOfBounds(row, column) || visited[row][column]) {</b>
<b class="fc">&nbsp;                return 0;</b>
&nbsp;            } else {
&nbsp;                try {
&nbsp;                    //if equal tile found add 1
<b class="fc">&nbsp;                    if (shelf.getTile(row, column).equals(type)) {</b>
<b class="fc">&nbsp;                        visited[row][column] = true;</b>
&nbsp;                        //recursively visit all neighbours of nth grade until you fill the island
&nbsp;                        //and add one for each one you find
<b class="fc">&nbsp;                        result = 1 + position.neighbours().stream().</b>
<b class="fc">&nbsp;                                mapToInt(neighbour -&gt; recursiveIslandVisit(shelf, neighbour, visited, type)).</b>
<b class="fc">&nbsp;                                sum();</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (BadPositionException e) {</b>
<b class="nc">&nbsp;                    throw new CommonGoalRuntimeException(&quot;Error in recursiveIslandVisit&quot;);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the size of the &quot;island&quot; of Tiles with the same color in which the selected tile is in.
&nbsp;         * If the Tile is Empty or Invalid it returns 0. Visited Tiles are marked on visited
&nbsp;         *
&nbsp;         * @param shelf    the player&#39;s shelf
&nbsp;         * @param position is the position of the Tile
&nbsp;         * @param visited  a matrix of booleans that keeps track of the visited Tiles
&nbsp;         * @return the size of the island
&nbsp;         */
&nbsp;        static private int validIslandSize(Shelf shelf, Position position, boolean[][] visited) {
<b class="fc">&nbsp;            if (shelf.isValidTile(position)) {</b>
<b class="fc">&nbsp;                Tile islandType = null;</b>
&nbsp;                try {
<b class="fc">&nbsp;                    islandType = shelf.getTile(position);</b>
<b class="nc">&nbsp;                } catch (BadPositionException e) {</b>
<b class="nc">&nbsp;                    throw new CommonGoalRuntimeException(&quot;Error in validIslandSize&quot;);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;                //return the size of the island
<b class="fc">&nbsp;                return recursiveIslandVisit(shelf, position, visited, islandType);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return 0;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * is true when the tiles form a ladder in the shelf
&nbsp;         */
<b class="fc">&nbsp;        static Predicate&lt;Shelf&gt; fullLadder = (shelf) -&gt; {</b>
&nbsp;            //get all heights in order
<b class="fc">&nbsp;            int[] heights = new int[shelf.getColumns()];</b>
<b class="fc">&nbsp;            for (int column = 0; column &lt; shelf.getColumns(); column++) {</b>
<b class="fc">&nbsp;                heights[column] = columnHeigth(shelf, column);</b>
&nbsp;            }
&nbsp;            //check if they form a ladder
<b class="fc">&nbsp;            return isLadder(heights);</b>
&nbsp;        };
&nbsp;        static private int columnHeigth(Shelf shelf, int column){
<b class="fc">&nbsp;            return (int) shelf.allTilesInColumn(column).stream()</b>
<b class="fc">&nbsp;                    .filter(x -&gt; !x.equals(Tile.Empty)).count();</b>
&nbsp;        }
&nbsp;        static private boolean isLadder(int[] heights) {
<b class="fc">&nbsp;            if (heights.length == 1) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;            //check if heights form an ascending ladder
<b class="fc">&nbsp;            boolean ascending = true;</b>
<b class="fc">&nbsp;            int expected = heights[0] + 1;</b>
<b class="fc">&nbsp;            for (int i = 1; i &lt; heights.length; i++) {</b>
<b class="fc">&nbsp;                ascending = ascending &amp;&amp; heights[i] == expected;</b>
<b class="fc">&nbsp;                expected++;</b>
&nbsp;            }
&nbsp;
&nbsp;            //check if heights form a descending ladder
<b class="fc">&nbsp;            boolean descending = true;</b>
<b class="fc">&nbsp;            expected = heights[0] - 1;</b>
<b class="fc">&nbsp;            for (int i = 1; i &lt; heights.length; i++) {</b>
<b class="fc">&nbsp;                descending = descending &amp;&amp; heights[i] == expected;</b>
<b class="fc">&nbsp;                expected--;</b>
&nbsp;            }
<b class="fc">&nbsp;            return ascending || descending;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * is true when the shelf contains a ladder of non-empty and equal tiles
&nbsp;         */
<b class="fc">&nbsp;        static Predicate&lt;Shelf&gt; ladder = (shelf) -&gt; {</b>
&nbsp;            //generate ladders
<b class="fc">&nbsp;            ArrayList&lt;ArrayList&lt;Tile&gt;&gt; ladders = null;</b>
<b class="fc">&nbsp;            ladders = generateLadders(shelf);</b>
&nbsp;            //check if at least one is composed of all equal tiles
<b class="fc">&nbsp;            for (ArrayList&lt;Tile&gt; ladder : ladders) {</b>
<b class="fc">&nbsp;                if (Predicates.maxNtypes(1).test(ladder)) {</b>
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        };
&nbsp;        static private ArrayList&lt;ArrayList&lt;Tile&gt;&gt; generateLadders(Shelf shelf) {
<b class="fc">&nbsp;            int rows = shelf.getRows();</b>
<b class="fc">&nbsp;            int columns = shelf.getColumns();</b>
<b class="fc">&nbsp;            ArrayList&lt;ArrayList&lt;Tile&gt;&gt; ladders = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            ArrayList&lt;Tile&gt; currentLadder = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;            //collect tiles in ascending ladders
<b class="fc">&nbsp;            for (int initial_row = 0; initial_row &lt; 2; initial_row++) {//value 2 is hardcoded</b>
&nbsp;                try{
<b class="fc">&nbsp;                    ladders.add((ArrayList&lt;Tile&gt;) ascendingLadder(shelf,initial_row));</b>
<b class="fc">&nbsp;                    ladders.add((ArrayList&lt;Tile&gt;) descendingLadder(shelf,initial_row));</b>
&nbsp;                }
<b class="nc">&nbsp;                catch (CommonGoalRuntimeException e){</b>
<b class="nc">&nbsp;                    throw new CommonGoalRuntimeException(&quot;Error in generateLadders&quot;);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;            return ladders;</b>
&nbsp;        }
&nbsp;        static private List&lt;Tile&gt; ascendingLadder(Shelf shelf,int initial_row) throws CommonGoalRuntimeException{
<b class="fc">&nbsp;            int rows = shelf.getRows();</b>
<b class="fc">&nbsp;            int columns = shelf.getColumns();</b>
<b class="fc">&nbsp;            List&lt;Tile&gt; ladder = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; Math.min(rows, columns); i++) {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    ladder.add(shelf.getTile(new Position(initial_row + i, i)));</b>
<b class="nc">&nbsp;                } catch (BadPositionException e) {</b>
<b class="nc">&nbsp;                    throw new CommonGoalRuntimeException(&quot;Error in generateLadders&quot;);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;            return ladder;</b>
&nbsp;        }
&nbsp;
&nbsp;        static private List&lt;Tile&gt; descendingLadder(Shelf shelf,int initial_row) throws CommonGoalRuntimeException{
<b class="fc">&nbsp;            int rows = shelf.getRows();</b>
<b class="fc">&nbsp;            int columns = shelf.getColumns();</b>
<b class="fc">&nbsp;            List&lt;Tile&gt; ladder = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; Math.min(rows, columns); i++) {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    ladder.add(shelf.getTile(new Position(initial_row + i, columns - 1 - i)));</b>
<b class="nc">&nbsp;                } catch (BadPositionException e) {</b>
<b class="nc">&nbsp;                    throw new CommonGoalRuntimeException(&quot;Error in generateLadders&quot;);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;            return ladder;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-06-30 07:29</div>
</div>
</body>
</html>
